<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="TCP/IP,网络层,计算机网络," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="看到一篇非常棒的系统讲解TCP/IP协议的博客，转载过来自己整理下。
什么是虚拟网络互连?&amp;nbsp;&amp;nbsp; &amp;nbsp; 所谓虚拟互连网络也就是逻辑互连网络,它的意思就是互连起来的各种物理网络的异构性本来是客观存在的(比如局域网有的采用的是以太网,&amp;nbsp;有的采用令牌环网),但是我们利用&amp;nbsp;IP&amp;nbsp;协议就可以使这些性能各异的网络从用户角度来看好像是一个统一的网络(在网络">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP/IP入门(2) --网络层">
<meta property="og:url" content="http://yoursite.com/2017/TCPIP入门(2)--网络层/index.html">
<meta property="og:site_name" content="Mr.Zhang's Coding Life">
<meta property="og:description" content="看到一篇非常棒的系统讲解TCP/IP协议的博客，转载过来自己整理下。
什么是虚拟网络互连?&amp;nbsp;&amp;nbsp; &amp;nbsp; 所谓虚拟互连网络也就是逻辑互连网络,它的意思就是互连起来的各种物理网络的异构性本来是客观存在的(比如局域网有的采用的是以太网,&amp;nbsp;有的采用令牌环网),但是我们利用&amp;nbsp;IP&amp;nbsp;协议就可以使这些性能各异的网络从用户角度来看好像是一个统一的网络(在网络">
<meta property="og:image" content="http://img.blog.csdn.net/20150407205043361?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407205400343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407205735436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407205835028?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407210036349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407210045753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407210342411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407210438115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407210950958?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407211044263?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407211144261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407212554700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407211151484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407211329830?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407211450011?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20150407211420561?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:updated_time" content="2017-04-23T14:41:33.970Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TCP/IP入门(2) --网络层">
<meta name="twitter:description" content="看到一篇非常棒的系统讲解TCP/IP协议的博客，转载过来自己整理下。
什么是虚拟网络互连?&amp;nbsp;&amp;nbsp; &amp;nbsp; 所谓虚拟互连网络也就是逻辑互连网络,它的意思就是互连起来的各种物理网络的异构性本来是客观存在的(比如局域网有的采用的是以太网,&amp;nbsp;有的采用令牌环网),但是我们利用&amp;nbsp;IP&amp;nbsp;协议就可以使这些性能各异的网络从用户角度来看好像是一个统一的网络(在网络">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> TCP/IP入门(2) --网络层 | Mr.Zhang's Coding Life </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7ccda0d578d22c62e4a93038a6095937";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mr.Zhang's Coding Life</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">张先生的成长日记</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                TCP/IP入门(2) --网络层
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-17T11:00:00+08:00" content="2017-04-17">
              2017-04-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/source/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/TCPIP入门(2)--网络层/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/TCPIP入门(2)--网络层/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>看到一篇非常棒的系统讲解TCP/IP协议的博客，转载过来自己整理下。</p>
<h2 id="什么是虚拟网络互连?&nbsp;"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">什么是虚拟网络互连?&nbsp;</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp; 所谓虚拟互连网络也就是逻辑互连网络,它的意思就是互连起来的各种<span style="color:rgb(0,0,255);">物理网络的异构性本来是客观存在的(比如局域网有的采用的是以太网,&nbsp;有的采用令牌环网)</span>,但是我们利用&nbsp;<span style="color:rgb(0,0,255);">IP&nbsp;协议</span>就可以使这些性能各异的网络从用户角度来看好像是一个统一的网络(在网络的上层,&nbsp;我们看不到各网络具体的异构网络细节)。使用IP&nbsp;协议的虚拟互连网络可简称为&nbsp;IP&nbsp;网。&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;好处是:&nbsp;当互联网上的处于不同网络的主机之间进行通信时,&nbsp;就好像在一个网络上通信一样,&nbsp;而看不见互连的各具体的网络异构细节(如具体的编址方案,&nbsp;路由选择协议等).</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<h2 id="IP报文"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">IP报文</span></span></h2><p><span style="font-family:Courier New;"><img src="http://img.blog.csdn.net/20150407205043361?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><table cellpadding="0" cellspacing="0"></table></p>
<p><span style="font-family:Courier New;"></span><table><tbody><tr><td width="568" valign="top" colspan="2" style="background:rgb(155,187,89);"><p style="text-align: center;"><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">各个字段说明</span></span><br></p></td></tr><tr><td valign="top" style="background:rgb(215,227,188);"></td></tr></tbody></table></p>
<p><span style="font-family:Courier New;">版本</span><br><td valign="top" style="background:rgb(215,227,188);"></td></p>
<p><span style="font-family:Courier New;">IP协议版本号,&nbsp;IPv4此字段值为4,&nbsp;IPv6此字段值为6</span><br><tr><td valign="top"></td></tr></p>
<p><span style="font-family:Courier New;">首部长度</span><br><td valign="top"></td></p>
<p><span style="font-family:Courier New;">取值范围5(0101)~15(1111),&nbsp;单位为4字节,包括固定部分和可选部分,&nbsp;因此首部最长为60字节,&nbsp;最短为20字节(不包括选项和填充部分);</span><br><tr><td valign="top" style="background:rgb(215,227,188);"></td></tr></p>
<p><span style="font-family:Courier New;">服务类型</span><br><td valign="top" style="background:rgb(215,227,188);"></td></p>
<p><span style="font-family:Courier New;">长度为8位(由于该字段一直弃而不用,&nbsp;因此不用考虑)</span><br><tr><td valign="top"></td></tr></p>
<p><span style="font-family:Courier New;">总长度</span><br><td valign="top"></td></p>
<p><span style="font-family:Courier New;">该字段长度为16位,&nbsp;以字节为单位,&nbsp;总长度包含<span style="color:rgb(0,0,255);">IP的头部和数据部分,&nbsp;IP数据报</span><span style="color:rgb(0,0,255);">最大长度为65535字节</span><span style="color:rgb(0,0,255);">,&nbsp;但是注意最大不要超过MTU的长度</span></span><br><tr><td valign="top" style="background:rgb(215,227,188);"></td></tr></p>
<p><span style="font-family:Courier New;">标识</span><br><td valign="top" style="background:rgb(215,227,188);"></td></p>
<p><span style="font-family:Courier New;">16位长度,&nbsp;唯一标识一个数据报,可以将之当成一个计数器,&nbsp;每发送一个数据包,&nbsp;则该值加1,&nbsp;如果数据报分片,则每个分片的标识都一样,&nbsp;各个分片共享一个标识号</span><br><tr><td valign="top"></td></tr></p>
<p><span style="font-family:Courier New;">标志</span><br><td valign="top"></td></p>
<p><span style="font-family:Courier New;">3位标志中第一位不使用,&nbsp;<span style="color:rgb(255,0,255);">第二位为DF(Don`t&nbsp;Fragment</span><span style="color:rgb(255,0,255);">不</span><span style="color:rgb(255,0,255);">分片</span><span style="color:rgb(255,0,255);">),&nbsp;如果该位为1,&nbsp;并且传输的数据报超过最大传输单元(MTU),&nbsp;则该数据报会被丢弃,&nbsp;并发送一个ICMP差错报文</span>;&nbsp;<span style="color:rgb(0,255,0);">第三位MF(More&nbsp;Fragment</span><span style="color:rgb(0,255,0);">更多</span><span style="color:rgb(0,255,0);">分片</span><span style="color:rgb(0,255,0);">),表示是否有更多的分片,&nbsp;如果该位为1,&nbsp;则说明后续还有分片,&nbsp;最后一片MF为0</span></span><br><tr><td valign="top" style="background:rgb(215,227,188);"></td></tr></p>
<p><span style="font-family:Courier New;">片偏移</span><br><td valign="top" style="background:rgb(215,227,188);"></td></p>
<p><span style="font-family:Courier New;">用以指出该分段的第一个数据字节在原始数据报中的偏移位置(以8字节为单位),IP分片后每一个分组都具有自己的首部,&nbsp;而且标志位相同,&nbsp;但是片偏移值不同,&nbsp;通过片偏移值接收端可以<span style="color:rgb(0,255,0);">重新组装IP包</span></span><br><tr><td valign="top"></td></tr></p>
<p><span style="font-family:Courier New;">生存时间<span style="color:rgb(255,0,0);">(TTL)</span></span><br><td valign="top"></td></p>
<p><span style="font-family:Courier New;">表示数据报最多可经过的<span style="color:rgb(255,0,0);">路由器的数量</span>.&nbsp;取值0～255,每经过一个路由器,&nbsp;TTL值减1,为0时被丢弃,&nbsp;并发送ICMP报文通知源主机,&nbsp;TTL可以避免数据报在路由器之间不断循环(Tranceroute程序的实现原理)</span><br><tr><td valign="top" style="background:rgb(215,227,188);"></td></tr></p>
<p><span style="font-family:Courier New;">协议类型</span><br><td valign="top" style="background:rgb(215,227,188);"></td></p>
<p><span style="font-family:Courier New;"><span style="color:rgb(255,0,0);">指明</span><span style="color:rgb(255,0,0);">IP层上承载的是哪个高级协议</span>,&nbsp;在分用的过程中,&nbsp;协议栈知道该交给上层的哪个协议处理,&nbsp;如1为ICMP,&nbsp;2为IGMP,&nbsp;6为TCP,&nbsp;17为UDP等.</span><br><tr><td valign="top"></td></tr></p>
<p><span style="font-family:Courier New;">头部校验和</span><br><td valign="top"></td></p>
<p><span style="font-family:Courier New;">保证数据报头部的数据完整性,但校验不包括数据部分。这样做的目的有二：一是所有将数据封装在IP数据包中的高层协议均含有覆盖整个数据的校验和,因此IP数据报没有必要再对其所承载的数据部分进行校验。二是每经过一个路由器,IP数据报的头部要发生改变(如TTL),而数据部分不变,这样只对发生改变的头部进行校验,显然不会浪费太多的时间。为了减少计算时间,一般不用CRC校验码,而是采用更简单的网际校验和(Internet&nbsp;Checksum)。</span><br><tr><td valign="top" style="background:rgb(215,227,188);"></td></tr></p>
<p><span style="font-family:Courier New;">选项与填充</span><br><td valign="top" style="background:rgb(215,227,188);"></td></p>
<p><span style="font-family:Courier New;">增加首部的可变部分是为了增加IP数据报的功能,&nbsp;如支持排错,&nbsp;测量以及安全等,&nbsp;选项长度从1到40字节不等,&nbsp;取决于所选择的项目(选项为4字节整数倍,否则用0填充);&nbsp;但这样就增加了每一个路由器处理数据的开销,&nbsp;实际上这些选项很少被使用,&nbsp;很多路由器都并不考虑IP首部的选项字段;</span><br><span style="font-family:Courier New;">&nbsp;</span></p><p></p>
<h2 id="IP地址分类"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">IP地址分类</span></span></h2><p><span style="font-family:Courier New;">IP地址的编址方法,共经历了三个历史阶段。这三个阶段是：</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp; 1)<span style="color:rgb(0,0,255);">分类的&nbsp;IP&nbsp;地址</span>。这是最基本的编址方法;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)<span style="color:rgb(0,0,255);">划分子网</span>。这是对最基本的编址方法的改进;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)<span style="color:rgb(0,0,255);">构成超网</span>。这是比较新的无分类编址方法,提出后很快得到推广,&nbsp;并沿用至今;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>分类的IP地址:</strong></span></p>
<table cellpadding="0" cellspacing="0"></table>

<p><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407205400343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<p><span style="font-family:Courier New;">A)为了适应不同网络规模的需求,将IP地址进行分类,<span style="color:rgb(255,0,0);">不同类型IP地址拥有的主机数不一样</span>。两级的&nbsp;IP&nbsp;地址可以记为：</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;IP&nbsp;地址&nbsp;::=&nbsp;{&nbsp;&lt;网络号&gt;,&nbsp;&lt;主机号&gt;}</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;">B)特殊地址&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;对于因特网&nbsp;IP&nbsp;地址中有特定的专用地址,不作分配(但他们还是IP地址):&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(1)&nbsp;<span style="color:rgb(51,102,255);">主机地址全为&quot;0&quot;</span>&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;不论哪类网络,主机地址全为&quot;0&quot;表示<span style="color:rgb(255,0,0);">指向本网</span>,常用在路由表中。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(2)&nbsp;<span style="color:rgb(51,102,255);">主机地址全为&quot;1&quot;&nbsp;</span></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;主机地址全为&quot;1&quot;表示<span style="color:rgb(255,0,0);">广播地址</span>,向特定的所在网上所有主机发送数据报。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(3)&nbsp;<span style="color:rgb(51,102,255);">32位全为&quot;1&quot;</span>&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;若&nbsp;IP&nbsp;地址&nbsp;4&nbsp;字节&nbsp;32&nbsp;比特全为&quot;1&quot;,表示仅在<span style="color:rgb(51, 102, 255);">本网内进行广播发送</span><span style="color:rgb(51, 102, 255);">(见Arp协议)</span>。&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(4)&nbsp;<span style="color:rgb(51,102,255);">网络为127&nbsp;</span></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;TCP/IP&nbsp;协议规定<span style="color:rgb(51,102,255);">网络号&nbsp;127&nbsp;不可用于任何网络</span>。其中有一个特别地址:127.0.0.1&nbsp;称之为还回地址(loop-back);</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;">C)使用范围:</span></p>
<table><tbody><tr><td valign="top" style="background:rgb(79,129,189);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">网络类别</span></span><br></td><td valign="top" style="background:rgb(79,129,189);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">最大网络数</span></span><br></td><td valign="top" style="background:rgb(79,129,189);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">第一个可用的网络号</span></span><br></td><td valign="top" style="background:rgb(79,129,189);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">最后一个可用的网络号</span></span><br></td><td valign="top" style="background:rgb(79,129,189);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">每个网络中的最大主机数</span></span><br></td></tr><tr><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">A</span><br></td><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">2^7&nbsp;-2</span><br></td><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">1</span><br></td><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">126(127不可用)</span><br></td><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">2^24&nbsp;-2</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">B</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">2^14&nbsp;-1</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">128.1</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">191.255</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">2^16&nbsp;-2</span><br></td></tr><tr><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">C</span><br></td><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">2^21&nbsp;-1</span><br></td><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">192.0.1</span><br></td><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">223.255.255</span><br></td><td valign="top" style="background:rgb(184,204,228);"><br><br><span style="font-family:Courier New;">2^8&nbsp;-2</span><br></td></tr></tbody></table>

<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;">D)IP地址的重要特点</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)IP&nbsp;地址是一种分等级的地址结构。分两个等级的好处是：</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;a.&nbsp;IP&nbsp;地址管理机构在分配&nbsp;IP&nbsp;地址时<span style="color:rgb(51,102,255);">只分配网络号</span>,而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了&nbsp;IP&nbsp;地址的管理。</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;b.&nbsp;<span style="color:rgb(51,102,255);">路由器仅根据目的主机所连接的网络号来转发分组</span>(而不考虑目的主机号),&nbsp;这样就可以<span style="color:rgb(255,0,255);">使路由表中的项目数大幅度减少</span><span style="color:rgb(255,0,255);">,</span><span style="color:rgb(255,0,255);">从而减小了路由表所占的存储空间</span>。&nbsp;</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;2)实际上&nbsp;IP&nbsp;地址是<span style="color:rgb(51,102,255);">标志一个主机/路由器和一条链路的接口</span>。&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;当一个主机同时连接到两个网络上时,该主机就必须同时具有两个IP&nbsp;地址,其<span style="color:rgb(51,102,255);">网络号&nbsp;net-id&nbsp;必须是不同的</span>;&nbsp;由于一个路由器至少应当连接到两个网络(这样它才能将&nbsp;IP&nbsp;数据报从一个网络转发到另一个网络),因此一个路由器至少应当有两个不同的&nbsp;IP&nbsp;地址。&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)用<span style="color:rgb(51,102,255);">转发器或网桥</span>连接起来的<span style="color:rgb(51,102,255);">若干个局域网仍为一个网络</span>,因此这些局域网都具有同样的网络号&nbsp;net-id。</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;4)所有分配到net-id&nbsp;的网络,&nbsp;无论是范围很小的局域网,还是覆盖很大地理范围的广域网,都是<span style="color:rgb(51,102,255);">平等的</span>。</span><br><span style="font-family:Courier New;"><br></span></p>
<h2 id="分组转发算法"><span style="font-family: 'Courier New';"><span style="color:#ff0000;">分组转发算法</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp; (1)&nbsp;&nbsp;从数据报的首部提取目的站的&nbsp;IP&nbsp;地址&nbsp;D,&nbsp;得出目的<span style="color:rgb(0,0,255);">网络地址为&nbsp;N</span>。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>(2)&nbsp;&nbsp;若网络&nbsp;N&nbsp;与此路由器<span style="color:rgb(0,0,255);">直接相连</span>,则直接将数据报直接交付给目的站&nbsp;D；否则是间接交付,执行(3)。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>(3)&nbsp;&nbsp;若路由表中有目的地址为&nbsp;D&nbsp;的<span style="color:rgb(0,0,255);">特定主机路由</span>,则将数据报传送给路由表中所指明的<span style="color:rgb(0,0,255);">下一跳路由器</span>；否则,执行(4)。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>(4)&nbsp;&nbsp;若路由表中有<span style="color:rgb(0,0,255);">到达网络&nbsp;N&nbsp;的路由</span>,则将数据报传送给路由表指明的下一跳路由器；否则,执行(5)。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>(5)&nbsp;若路由表中有一个<span style="color:rgb(0,0,255);">默认路由</span>,则将数据报传送给路由表中所指明的默认路由器；否则,执行(6)。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>(6)&nbsp;&nbsp;报告转发分组出错。</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<h2 id="子网划分"><span style="font-family: 'Courier New';"><span style="color:#ff0000;">子网划分</span></span></h2><p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>一个拥有许多物理网络的单位,可将所属的<span style="color:rgb(51,102,255);">物理网络划分为若干个子网</span>。划分子网纯属一个单位内部的事情。<span style="color:rgb(51,102,255);">本单位以外的网络看不见这个网络是由多少子网组成</span>,因为这个单位对外仍然表现一个网络。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>划分子网的方法是从网络的<span style="color:rgb(51,102,255);">主机号借用若干位作为子网号subnet-id</span>。划分子网增加了灵活性,但也减少了能够连接在网络上主机总数。于是两级IP地址在本单位内部就变为三级IP地址:</span></p>
<p><span style="color:rgb(51,102,255);"><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>IP地址&nbsp;::=&nbsp;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</span></span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>凡是从其他网络发送给本单位某个主机的IP数据报,仍然是根据<span style="color:rgb(51,102,255);">IP数据报的目的网络号找到连接在本单位网络上的路由器</span>。但此<span style="color:rgb(51,102,255);">路由器在收到IP数据报后</span><span style="color:rgb(51,102,255);">,</span><span style="color:rgb(51,102,255);">在按目的网络号和子网号找到目的子网</span><span style="color:rgb(51,102,255);">,</span><span style="color:rgb(51,102,255);">把IP数据报交付给目的主机;</span></span></p>
<p><span style="color:rgb(51,102,255);"><span style="font-family:Courier New;">&nbsp;</span></span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>子网掩码</strong></span></p>
<p><span style="font-family:Courier New;">    <span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>子网掩码也是32位,由一串1和跟随的一串0组成。子网掩码中的<span style="color:rgb(255,0,255);">1</span>对应于IP地址中原来的<span style="color:rgb(255,0,255);">网络号</span>和<span style="color:rgb(255,0,255);">子网号</span>,而子网掩码中的<span style="color:rgb(0,0,255);">0</span>对应于现在的<span style="color:rgb(0,0,255);">主机号</span>。故将子网掩码和IP地址进行按位”与“运算(AND),就可得出网络地址,&nbsp;由此可知:</span></p>
<table style="font-size:14px;"><tbody><tr><td valign="top" style="background:rgb(192,80,77);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">A&nbsp;类网络的缺省的子网掩码是</span></span><br></td><td valign="top" style="background:rgb(192,80,77);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">255.0.0.0</span></span><br></td></tr><tr><td valign="top" style="background:rgb(229,185,183);"><br><br><span style="font-family:Courier New;">B&nbsp;类网络的缺省的子网掩码是</span><br></td><td valign="top" style="background:rgb(229,185,183);"><br><br><span style="font-family:Courier New;">255.255.0.0</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">C&nbsp;类网络的缺省的子网掩码是</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">255.255.255.0(最常见)</span><br></td></tr></tbody></table>

<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>不同的子网掩码可以得出相同的网络地址,&nbsp;但不同的掩码的效果是不同的.</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><strong><span style="font-family:Courier New;font-size:18px;">使用子网时分组的转发过程:</span></strong></p>
<p><span style="font-family:Courier New;">使用子网划分后,路由表必须包含以下三项内容：{目的网络地址,子网掩码和下一跳地址},&nbsp;路由器转发分组的流程如下：</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>1)从收到的数据报首部提取目的IP地址D;</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>2)先判断是否为<span style="color:rgb(0,0,255);">直接交付</span>。对路由器直接相连的网络进行逐个检查：用<span style="color:rgb(0,0,255);">各网络的子网掩码和D逐位相与</span><span style="color:rgb(0,0,255);">,</span><span style="color:rgb(0,0,255);">看结果是否和相对应的网络地址匹配</span>。若匹配,则把分组进行直接交付,转发任务结束。否则就是间接交付,执行(3)。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>3)若路由表中有目的地址为D的<span style="color:rgb(0,0,255);">特定主机路由</span>,则把数据报传送给路由表中所指明的下一跳路由,否则执行(4)。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>4)对路由表的每一行,用其中的子网掩码和D逐位相与,其结果为N。若N与该行的目的<span style="color:rgb(0,0,255);">网络地址匹配</span>,则把数据报传送给该行指明的<span style="color:rgb(0,0,255);">下一跳路由器</span>,否则执行(5)。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>5)若路由表中有一个<span style="color:rgb(0,0,255);">默认路由</span>,则把数据报传送给路由表中所指明的默认路由器；否则执行(6)。</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:14px;">&nbsp; &nbsp;&nbsp;</span>6)报告转发分组出错。</span><br><span style="font-family:Courier New;"><br></span></p>
<h2 id="无分类编址(CIDR)&nbsp;"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">无分类编址(CIDR)&nbsp;</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp; 无分类域间路由选择(CIDR)是在变长子网掩码的基础上提出的一个消除A,&nbsp;B,&nbsp;C类网络划分,&nbsp;并且可以在软件的支持下实现构造超网的一种IP地址的划分方法;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>CIDR的主要特点:</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)<span style="color:rgb(0,0,255);">消除了传统的A,B,C类地址以及子网划分的概念,&nbsp;因而可以更加有效的分配IPv4的地址空间</span>.&nbsp;CIDR使用”网络前缀”的概念代替网络号的概念,&nbsp;这样IP地址的无分类两级编址就变为:</span></p>
<p><span style="background:rgb(217,217,217);"><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;IP::=&nbsp;{&lt;网络前缀&gt;,&lt;主机地址&gt;}</span></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;CIDR还使用”斜线记法”,&nbsp;即:&nbsp;&lt;IP地址&gt;/&lt;网络前缀所占位数&gt;.&nbsp;其中,&nbsp;网络前缀所占位数对应于网络号部分,&nbsp;等效于子网掩码中连续1的部分,&nbsp;因此通过逐位相”与”的方法依然可以得到该地址的网络前缀;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;注:CIDR并不使用子网,&nbsp;&nbsp;CIDR并没有在32位地址中指明若干位作为子网字段,&nbsp;但分配到一个CIDR地址块的组织仍可以在本组织内根据需要划分出一些子网;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)<span style="color:rgb(0, 0, 255);">将网络前缀都相同的连续的IP地址组成”CIDR地址块”</span>,&nbsp;一个CIDR地址块可以表示很多地址,&nbsp;这种地址的聚合成为<span style="color:rgb(0,0,255);">路由聚合</span>,&nbsp;或称<span style="color:rgb(0,0,255);">构成超网</span>;&nbsp;路由聚合使得路由表中的一个项目可以表示很多个原来传统分类地址的路由,&nbsp;有利于减少路由器之间的路由选择信息的交换,&nbsp;从而提高网络性能.</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>最长前缀匹配</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;使用CIDR时,&nbsp;路由表中的每个项目由”网络前缀”和”下一跳地址”组成.&nbsp;在查找路由表时可能会得到不止一个匹配结果,&nbsp;应当从匹配结果中选择具有最长网络前缀的路由,&nbsp;因为网络前缀越长,&nbsp;其地址块就越小,&nbsp;因而路由就越具体;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;CIDR查找路由表的方法:&nbsp;为了进行更加有效地查找最长前缀匹配,&nbsp;通常是将无分类编址的路由表存放在一种层次的数据结构中,&nbsp;然后自上而下地按层次进行查找,&nbsp;这就是最常用的二叉线索;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<h2 id="网络地址转换NAT"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">网络地址转换NAT</span></span></h2><p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;网络地址转换(NAT,Network&nbsp;Address&nbsp;Translation)属接入广域网(WAN)的技术,是一种<span style="color:rgb(0,0,255);">将私有</span><span style="color:rgb(0,0,255);">(</span><span style="color:rgb(0,0,255);">保留</span><span style="color:rgb(0,0,255);">)</span><span style="color:rgb(0,0,255);">地址转化为合法IP地址的转换技术</span>.&nbsp;NAT不仅完美地解决了<span style="color:rgb(255,0,0);">IP地址不足</span>的问题,而且还能够有效地<span style="color:rgb(255,0,0);">避免来自网络外部的攻击</span>,<span style="color:rgb(255,0,0);">隐藏并保护网络内部的计算机</span>。</span></p>
<table><tbody><tr><td width="319" valign="top" colspan="2" style="background:rgb(75,172,198);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">三个私有IP地址块</span></span><br></td></tr><tr><td valign="top" style="background:rgb(183,221,232);"><br><br><span style="font-family:Courier New;">A&nbsp;类</span><br></td><td valign="top" style="background:rgb(183,221,232);"><br><br><span style="color:rgb(255,0,0);"><span style="font-family:Courier New;">10.0.0.0&nbsp;~&nbsp;10.255.255.255</span></span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">B&nbsp;类</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">172.16.0.0&nbsp;~&nbsp;172.31.255.255</span><br></td></tr><tr><td valign="top" style="background:rgb(183,221,232);"><br><br><span style="font-family:Courier New;">C&nbsp;类</span><br></td><td valign="top" style="background:rgb(183,221,232);"><br><br><span style="color:rgb(255,0,0);"><span style="font-family:Courier New;">192.168.0.0&nbsp;~&nbsp;192.168.255.255</span></span><br></td></tr></tbody></table>

<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;上述三个范围内的地址<span style="color:rgb(255,0,0);">不会在因特网上被分配(因此路由器并不会路由</span><span style="color:rgb(255,0,0);">这些</span><span style="color:rgb(255,0,0);">IP地址)</span>,因此可以不必向ISP&nbsp;或注册中心申请而在公司或企业内部自由使用。</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><strong><span style="font-family:Courier New;font-size:18px;">NAT工作流程</span></strong></p>
<table cellpadding="0" cellspacing="0"></table>

<p><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407205735436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;①如图这个&nbsp;client(终端)&nbsp;的&nbsp;gateway&nbsp;(网关)设定为&nbsp;NAT&nbsp;主机,所以当要连上&nbsp;Internet&nbsp;的时候,该封包就会被送到&nbsp;NAT&nbsp;主机,这个时候的封包&nbsp;Header&nbsp;之&nbsp;source&nbsp;IP为&nbsp;192.168.1.100;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;②而透过这个&nbsp;NAT&nbsp;主机,它会将&nbsp;client&nbsp;的对外联机封包的&nbsp;source&nbsp;IP&nbsp;(&nbsp;192.168.1.100&nbsp;)&nbsp;伪装成&nbsp;ppp0&nbsp;(&nbsp;假设为拨接情况&nbsp;)这个接口所具有的公共&nbsp;IP&nbsp;,因为是公共&nbsp;IP&nbsp;了,所以这个封包就可以连上&nbsp;Internet&nbsp;了！同时&nbsp;<span style="color:rgb(255,0,0);">NAT&nbsp;主机并且会记忆这个联机的封包是由哪一个&nbsp;(&nbsp;192.168.1.100&nbsp;)&nbsp;client&nbsp;端传送来的</span>；</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;③由&nbsp;Internet&nbsp;传送回来的封包,当然由&nbsp;NAT主机来接收了,这个时候,&nbsp;NAT&nbsp;主机会去查询原本记录的路由信息,并将目标&nbsp;IP&nbsp;由&nbsp;ppp0&nbsp;上面的公共&nbsp;IP&nbsp;改回原来的&nbsp;192.168.1.100&nbsp;；</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;④最后则由&nbsp;NAT&nbsp;主机将该封包传送给原先发送封包的&nbsp;Client.</span><br><span style="font-family:Courier New;"><br></span></p>
<h2 id="ARP协议"><span style="font-family:Courier New;"><span style="color:rgb(255, 0, 0);">ARP</span><span style="color:rgb(255, 0, 0);">协议</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp; ARP协议的用途：解决同一个局域网内主机或路由器的<span style="color:rgb(0,0,255);">IP地址和MAC地址的映射问题。</span></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp; 如图所示,假设在一个以太网上的&nbsp;4&nbsp;台计算机,分别是计算机&nbsp;A&nbsp;、&nbsp;B&nbsp;、&nbsp;X&nbsp;和&nbsp;Y&nbsp;,通过TCP/IP&nbsp;协议进行通信,那么双方的数据链路层必须知道对方的&nbsp;MAC&nbsp;地址。每台计算机都要在各自的高速缓存区中存放一张&nbsp;IP&nbsp;地址到&nbsp;MAC&nbsp;地址的转换表,称&nbsp;ARP&nbsp;表。其中存放着最近用到的一系列和它通信的处于同一子网的计算机的&nbsp;IP&nbsp;地址和&nbsp;MAC&nbsp;地址的映射。在主机初始启动时,&nbsp;ARP&nbsp;表为空。现在源端计算机&nbsp;A&nbsp;(&nbsp;192.168.3.1&nbsp;)要和计算机&nbsp;B(192.168.3.2)通信。在计算机&nbsp;A&nbsp;发送信息前,&nbsp;必须首先得到计算机B的MAC地址的映射关系。&nbsp;ARP&nbsp;协议工作过程如下:&nbsp;</span></p>
<p><span style="font-family:Courier New;"><img src="http://img.blog.csdn.net/20150407205835028?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></p>
<table cellpadding="0" cellspacing="0"></table>

<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;(1)主机&nbsp;A&nbsp;首先查看自己的高速缓存中的&nbsp;ARP缓存表,看其中是否有与&nbsp;192.168.3.2&nbsp;对应的&nbsp;ARP&nbsp;表项。如果找到,则直接利用该&nbsp;ARP&nbsp;表项中的&nbsp;MAC&nbsp;值把&nbsp;IP&nbsp;数据包封装成帧发送给主机B。&nbsp;</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;(2)如果在&nbsp;ARP&nbsp;表中找不到对应的地址项,则创建一个&nbsp;ARP&nbsp;请求数据包,并以广播方式发送(把以太帧的目的地址设置为&nbsp;<span style="color:rgb(0,0,255);">FF-FF-FF-FF-FF-FF</span>)&nbsp;。包中有需要查询的目的计算机的&nbsp;IP&nbsp;地址(192.168.3.2)&nbsp;,&nbsp;以及主机&nbsp;A&nbsp;自己的&nbsp;IP&nbsp;地址和&nbsp;MAC&nbsp;地址。&nbsp;</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;(3)包括计算机&nbsp;B&nbsp;在内的属于&nbsp;192.168.3.0&nbsp;网络上的所有计算机都收到&nbsp;A&nbsp;的&nbsp;ARP&nbsp;请求包,<span style="color:rgb(0,0,255);">然后将计算机&nbsp;A&nbsp;的&nbsp;IP&nbsp;地址与&nbsp;MAC&nbsp;地址的映射关系存入各自的&nbsp;ARP&nbsp;表中。</span>&nbsp;</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;(4)计算机&nbsp;B&nbsp;创建一个&nbsp;ARP&nbsp;响应包,在包中填入自己的&nbsp;MAC&nbsp;地址,以单播方式直接发送给主机&nbsp;A。&nbsp;</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;(5)&nbsp;主机&nbsp;A&nbsp;收到响应后,&nbsp;从包中提取出所需查询的&nbsp;IP&nbsp;地址及其对应的&nbsp;MAC&nbsp;地址,&nbsp;添加到自己的&nbsp;ARP&nbsp;表中。并根据该&nbsp;MAC&nbsp;地址将所需要发送的数据包封装成帧发送出去。&nbsp;    </span></p>
<p><span style="font-family:Courier New;">注意:</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(1)ARP&nbsp;表的内容是定期更新的,如果一条&nbsp;ARP&nbsp;表项很久没有使用了,则它将被从&nbsp;ARP&nbsp;表中删除。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(2)如果所要找的主机和源主机不在同一个局域网上,&nbsp;那么就要通过ARP找到一个<span style="color:rgb(0,0,255);">位于本局域网上的某个</span><span style="color:rgb(255,0,0);">路由器</span><span style="color:rgb(0,0,255);">的硬件地址</span>,&nbsp;然后把分组发送给这个路由器,&nbsp;让这个路由器把分组转发给下一个网络,&nbsp;剩下的工作就由下一个网络来做.</span><br><span style="font-family:Courier New;"><br></span></p>
<h2 id="DHCP协议"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">DHCP协议</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp; DHCP动态主机配置协议常用于给主机<span style="color:rgb(0,0,255);">动态地分配IP地址</span>,&nbsp;他提供了即插即用联网的机制,这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与;&nbsp;DHCP是<span style="color:rgb(0,0,255);">应用层协议,&nbsp;他是基于UDP的</span>;</span></p>
<p><strong><span style="font-family:Courier New;font-size:18px;">DHCP工作原理:</span></strong></p>
<p><strong><span style="font-family:Courier New;font-size:18px;"><img src="http://img.blog.csdn.net/20150407210036349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></strong></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;首先,DHCP客户端发送DHCPDISCOVER消息(DHCP发现),这个消息是通过广播方式发送出去的,所有网络中的DHCP服务器都将接收到这个消息。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;随后,网络中的DHCP服务器会回应一个DHCPOFFER消息(DHCP提供),由于这个时候客户端还没有网络地址,所以DHCPOFFER也是通过广播的方式发送出去的。需要注意的是,由于网络中可能存在不止一台的DHCP服务器,所以,如果不考虑网络丢包的话,客户端将接收到不止一条的DHCPOFFER消息。那么<span style="color:rgb(0,0,255);">客户端会选择它接收到的第一条DHCPOFFER作为获取配置的服务器</span>。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;然后,DHCP客户端向该服务器发送DHCPREQUEST消息(DHCP请求)。虽然这个时候客户端已经明确知道选择的DHCP服务器的地址所在,但仍将采用<span style="color:rgb(0,0,255);">广播</span>的方式发送,这样做不仅可以通知选中的服务器向客户端分配IP地址,同时也可以<span style="color:rgb(0,0,255);">通知其他没有选中的DHCP服务器不需要再响应它的请求</span>。在DHCPREQUEST消息中将包含客户端申请的IP地址。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;最后,DHCP服务器将回送DHCPACK(DHCP确认)的响应消息来通知客户端可以使用该IP地址,该确认里面包含了分配的IP地址和该地址的一个稳定期限的租约(默认是8天),并同时更新DHCP数据库。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;当租约过了一半时(即4天),客户端将和设置它的TCP/IP配置的DHCP服务器更新租约。当租约过了85.7%时,如果客户端仍然无法与当初的DHCP服务器联系上,他将与其他DHCP服务器通信,如果网络中再没有任何DHCP服务器在运行时,该客户端停止使用该IP地址,并重新发送一个DHCPDISCOVER消息,再一次重复整个过程。</span><br><span style="font-family:Courier New;"><br></span></p>
<h2 id="ICMP协议"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">ICMP协议</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp; IP提供的是尽最大努力交付的无连接服务,因此并不能解决网络层中的数据报丢失、重复、延迟或乱序等问题,为了提高IP数据报成功交付的机会,&nbsp;在网络层使用ICMP(Internet&nbsp;Control&nbsp;Message&nbsp;Protocol：Internet控制报文协议)协议来允许主机或者路由器报告差错和异常情况.&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>ICMP的特征</strong></span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;a.ICMP就像一个更高层的协议那样<span style="color:rgb(255,0,0);">使用IP协议(ICMP消息被封装在IP数据报中)</span>;然而,ICMP是IP的一个组成部分,并且所有IP模块都必须实现它。</span></p>
<table cellpadding="0" cellspacing="0"></table>

<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;b.ICMP用来报告错误,是一个差错报告机制。它为遇到差错的路由器提供了<span style="color:rgb(255,0,0);">向最初源站报告差错的办法</span>,源站必须把差错交给一个应用程序或采取其它措施来纠正问题。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;c.ICMP报文的种类有两种:&nbsp;ICMP差错报告报文和ICMP询问报文;</span></p>
<p><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407210045753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<p><span style="font-family:Courier New;"><br></span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>ICMP差错报告报文</strong></span></p>
<table><tbody><tr><td width="568" valign="top" colspan="2" style="background:rgb(247,150,70);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">ICMP差错报告报文类型</span></span><br></td></tr><tr><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">终点不可达</span><br></td><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">当路由器检测到数据报无法传递到目的地时,向创建数据报的源主机发出终点不可达报文。这类报文分为：网络不通(如路由器故障),目的主机连不通(没开机),协议不可达、端口不可达等共15种不同的情况,用不同代码表示。</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">源点抑制</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">当路由器/主机收到太多的数据报以致来不及处理时,在丢弃所收数据报的同时,向创建数据报的源主机发送源点抑制报文。&nbsp;使源点知道应当把数据报的发送速率放慢。</span><br></td></tr><tr><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">时间超过</span><br></td><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">有两种情况需要发送超时报文:</span><br><br><span style="font-family:Courier New;">1.路由器把数据报的生存时间减至零时,路由器丢弃数据报,并向源主机发送时间超过报文；2.当终点在预先规定的时间内不能收到一个数据报的全部数据报分片时,&nbsp;就把已收到的数据报片全部丢弃,&nbsp;并向源点发送时间超过报文;</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">参数问题</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">当路由器/目的主机收到的数据报的首部有的字段的值不正确时,&nbsp;就丢弃该数据报,&nbsp;并向源点发送参数问题报文;</span><br></td></tr><tr><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">改变路由(重定向)</span><br></td><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">当一个源主机创建的数据报发至某路由器,该路由器发现数据报应该选择其他路由时,则向源主机发送改变路由报文。改变路由的报文能指出网络或特定主机的变化,一般发生在一个网络连接多路由器的情况下.</span><br></td></tr></tbody></table>

<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;">不应发送ICMP差错报告报文的几种情况:</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)对ICMP差错报告报文不再发送ICMP差错报告报文。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)对具有多播地址的数据报都不发送ICMP差错报告报文。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;4)对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>ICMP询问报文</strong></span></p>
<p><span style="font-family:Courier New;">回送请求和回答报文,&nbsp;时间戳请求和回答报文,&nbsp;掩码地址请求和回答报文,&nbsp;路由器询问和通告报文;</span></p>
<p><span style="font-family:Courier New;">常用的ICMP询问报文有两种,即：</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)回送请求和回答:&nbsp;ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态(Ping实现机制)。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)时间戳请求和回答:&nbsp;ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段,其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用来进行时钟同步和测量时间。&nbsp;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>Ping实现原理</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;Ping(Packet&nbsp;Internet&nbsp;Groper)分组网间探测是ICMP的一个重要应用,<span style="color:rgb(255,0,0);">用来测试两个主机之间的连通性</span>。Ping使用了ICMP<span style="color:rgb(255,0,0);">回送请求与回答报文</span>。Ping是应用层直接使用网络层ICMP的一个例子。它没有通过运输层的TCP或UDP。</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;实现原理为:&nbsp;ping向目的主机发送<span style="color:rgb(255,0,0);">4个32字节长的ICMP回送请求报文</span>,若目的主机正常工作并且响应了该ICMP回送请求报文,就将发回ICMP回送回答报文。最后可得出的统计结果为<span style="color:rgb(255,0,0);">目的IP地址</span><span style="color:rgb(255,0,0);">,</span><span style="color:rgb(255,0,0);">发送的</span><span style="color:rgb(255,0,0);">,</span><span style="color:rgb(255,0,0);">收到的和丢失的分组数</span><span style="color:rgb(255,0,0);">,</span><span style="color:rgb(255,0,0);">及往返时间的最小值、最大值和平均值</span>。</span></p>
<p><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407210342411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;ping命令格式为&nbsp;ping&nbsp;&lt;host-name&gt;    #host-name为要测试连通性的主机名/IP地址。</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>TraceRoute原理</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;Traceroute(Linux)/tracert(Windows)是用来侦测主机到目的主机之间所经路由情况的重要工具。它的原理如下：</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;源主机首先给目的主机发送一个<span style="color:rgb(255,0,0);">TTL=1</span>的UDP数据包,而经过的第一个路由器收到这个数据包以后,就自动把TTL减1,而TTL变为0以后,路由器就把这个包给丢弃了,并同时产生”<span style="color:rgb(255,0,0);">目的主机不可达</span>”的ICMP差错报告报文给源主机。源主机收到这个数据报以后再发一个<span style="color:rgb(255,0,0);">TTL=2</span>的UDP数据报给目的主机,然后刺激第二个路由器给源主机发送差错报文。如此往复直到到达目的主机。这样,traceroute就拿到了所有的路由器IP。</span><br><span style="font-family:Courier New;"><img src="http://img.blog.csdn.net/20150407210438115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><table cellpadding="0" cellspacing="0"></table></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<h2 id="RIP协议"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">RIP协议</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp; 路由信息协议RIP是一种分布式的基于<span style="color:rgb(255,0,0);">距离向量</span>的路由选择协议,&nbsp;属于内部网关协议(IGP)。<span style="color:rgb(255,0,0);">RIP协议中的“距离”也称为“跳数”</span>,每经过一个路由器,跳数就加1。协议规定:&nbsp;同一自治系统(A.S.)中的路由器<span style="color:rgb(255,0,0);">每30秒会与相邻的路由器交换</span><span style="color:rgb(255,0,0);">路由信息</span>,以动态的建立路由表。当传输数据时,RIP将选择一条具有最少路由器的路由。</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>RIP协议规定:</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)&nbsp;网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录(因此,&nbsp;这是一组距离,&nbsp;称”距离向量”);</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)&nbsp;距离也称为跳数(Hop&nbsp;Count),&nbsp;规定从一路由器到直接连接的网络跳数为1,&nbsp;而每经过一个路由器,&nbsp;则跳数加1;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)&nbsp;RIP认为好的路由就是它通过的路由器的数目少,&nbsp;即优先选择跳数少的路径;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;4)&nbsp;RIP允许一条路径最多只能包含15个路由器(即最多允许15跳),&nbsp;因此距离等于16时表示网络不可达.&nbsp;可见RIP只适用于小型互联网.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;5)&nbsp;RIP默认在任意两个使用RIP协议的路由器之间每30秒广播一次RIP路由更新信息.&nbsp;以便于自动建立并维护路由表(动态维护).</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;6)&nbsp;在RIP中不支持子网掩码的RIP广播,&nbsp;所以RIP中每个网络的子网掩码必须相同.&nbsp;但在新的RIP2中,&nbsp;支持变长子网掩码和CIDR.</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>RIP&nbsp;协议特点:</strong></span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;1)仅和<span style="color:rgb(255,0,0);">相邻路由器</span>交换信息。【注】如果两个路由器之间的通信不需要经过另一个路由器,那么这两个路由器就是相邻的。RIP协议规定,不相邻的路由器不交换信息。</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;2)路由器交换的信息是当前本路由器所知道的<span style="color:rgb(255,0,0);">全部信息</span>,即自己的路由表。【注】交换的信息是：“我到本自制系统中所有网路的(最短)距离,以及到每个网络应该经过的下一跳路由器。”</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;&nbsp;(3)按<span style="color:rgb(255,0,0);">固定的时间间隔</span>交换路由信息。【注】每隔30秒,路由器根据收到的路由信息更新路由表。当网路拓扑发生变化时,路由器也及时向相邻路由器通告拓扑变化后的路由信息。</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>距离向量算法</strong></span></p>
<p><span style="font-family:Courier New;">对每一个相邻路由器发送过来的RIP报文,进行以下步骤：</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;1)对地址为X的相邻路由器发来的RIP报文,先修改此报文中的所有项目：<span style="color:rgb(255,0,0);">把“下一跳”字段中的地址都改为X</span><span style="color:rgb(255,0,0);">,</span><span style="color:rgb(255,0,0);">并把所有的&quot;距离&quot;字段的值加1</span>.每个项目都有三个关键数据,即：目的网络N,距离是d,下一跳路由器是X。</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;2)对修改后的RIP报文中的每一个项目,进行如下步骤：</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;*&nbsp;若原来的路由表中没有目的网络N,则把该项目添加到路由表中;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;*&nbsp;否则,&nbsp;若下一跳路由器地址是X,则把收到的项目替换原路由表中的项(使用最新的路由信息);</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;*&nbsp;否则,&nbsp;若收到的项目中距离d小于路由表中的距离,则进行更新;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)若3分钟还没有收到相邻路由器的更新路由表,则把此相邻路由器记为不可到达的路由器,即把距离设置为16。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;4)返回</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>RIP路由协议优缺点</strong></span></p>
<p><span style="font-family:Courier New;">优点是配置简单,非常适用于小规模网络?</span></p>
<p><span style="font-family:Courier New;">RIP协议的缺点包括:</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)大量广播?RIP向所有邻居每隔30秒广播一次完整的路由表,将占用宝贵的带宽资源,在较慢的广域网链路上问题更加明显?</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)没有成本概念?RIP没有网络延迟和链路成本的概念?当采用RIP时,路由/转发的决定只是基于跳数,&nbsp;这样很容易导致无法选择最佳路由?&nbsp;例如,一条链路拥有较高的带宽,但是跳数较多,从而不能被选择?</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)支持的网络规模有限?由于RIP路由协议最多只支持16个步跳,当超过该跳数时,网络将认为无法到达?因此,RIP只能适用于规模较少的网络?</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;4)当网络出现故障时,&nbsp;会出现慢收敛现象(需要较长时间才能将此信息传送到所有路由器),&nbsp;俗称”坏消息传的慢”,&nbsp;使更新过程的收敛时间长;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;">小结:RIP是应用层协议,&nbsp;它使用UDP传送数据(端口520).&nbsp;RIP协议选择的路径不一定是最短的,&nbsp;但一定是具有最少路由器的路径.</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<h2 id="OSPF协议"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">OSPF协议</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;OSPF&nbsp;(Open&nbsp;Shortest&nbsp;Path&nbsp;First,&nbsp;开放最短路径优先)。它是为克服RIP的缺点在1989年开发出来的。OSPF的原理很简单,但实现起来却较复杂。“开放”表明OSPF协议不是受某一家厂商控制,而是公开发表的。“最短路径优先”是因为使用了Dijkstra最短路径算法。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;请注意:OSPF只是一个协议的名字,它并不表示其他的路由选择协议不是“最短路径优先”。实际上,所有的在自治系统内部使用的路由选择协议(包括RIP协议)都是要寻找一条最短的路径。</span></p>
<p><span style="font-family:Courier New;">    OSPF最主要的特征就是使用<span style="color:rgb(255,0,0);">分布式的链路状态协议</span>(link&nbsp;state&nbsp;protocol),而不是像RIP那样的距离向量协议。和RIP协议相比,OSPF的四个要点和RIP的都不一样:</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;(1)OSPF向本自治系统中<span style="color:rgb(255,0,0);">所有路由器</span>发送信息。这里使用的方法是<span style="color:rgb(255,0,0);">洪泛法</span>(flooding),这就是路由器通过所有输出端口向<span style="color:rgb(255,0,0);">所有相邻的路由器发送信息</span>。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样,最终整个区域中所有的路由器都得到了这个信息的一个副本。我们应注意,<span style="color:rgb(255,0,0);">RIP协议是仅仅向自己相邻的几个路由器发送信息</span>。</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;(2)OSPF发送的信息就是与本路由器<span style="color:rgb(255,0,0);">相邻的所有路由器的链路状态</span>,但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻,以及该链路的“度量”(metric)。OSPF将这个“度量”表示为费用、距离、时延、带宽等。这些都由网络管理人员来决定,因此较为灵活。有时为了方便就称这个度量为“代价”(注意:对于RIP协议,发送的信息是:“到所有网络的距离和下一跳路由器”)。</span></p>
<p><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;(3)<span style="color:rgb(255,0,0);">OSPF只有当链路状态发生变化时</span>,路由器才向所有路由器用洪泛法发送此信息。而不像RIP那样,不管网络拓扑有无发生变化,路由器之间都要定期交换路由表的信息。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(4)<span style="color:rgb(255,0,0);">OSPF是网络层协议</span>,&nbsp;他不使用UDP/TCP而是直接使用IP数据报传送(其IP数据报首部的协议字段为89).且OSPF数据报较短,&nbsp;不会导致IP数据报分片,&nbsp;因此更加高效;&nbsp;而RIP是应用层协议,&nbsp;他在传输层使用UDP协议.</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;">除了以上区别之外,&nbsp;OSPF还有以下特点:</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)&nbsp;OSPF对不同的链路可根据IP分组的不同服务类型(TOS)而设置成不同的代价.&nbsp;因此,&nbsp;OSPF对于不同类型的业务可计算出不同的路由,&nbsp;因此十分灵活.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)&nbsp;如果到同一个目的网络有多条相同代价的路径,&nbsp;那么OSPF可将通信量分配给这几条路径,&nbsp;这叫做多路径之间的<span style="color:rgb(0,0,255);">负载均衡</span>.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)&nbsp;所有在OSPF路由器之间交换的分组都具有<span style="color:rgb(0,0,255);">鉴别功能</span>,&nbsp;因而保证了仅在可信赖的路由器之间交换链路状态信息.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;4)&nbsp;OSPF支持可变长度的<span style="color:rgb(0,0,255);">子网划分和无分类编址CIDR</span>.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;5)&nbsp;每一个链路状态都带上一个32位的<span style="color:rgb(0,0,255);">序号</span>,&nbsp;序号越大状态就越新.</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>OSPF基本工作原理</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;由于各路由器之间频繁地交换链路状态信息,&nbsp;因此所有的路由器最终都能建立一个链路状态数据库.&nbsp;这个数据库实际上就是<span style="color:rgb(0,0,255);">全网的拓扑结构图</span>,&nbsp;他在全网范围内是一致的(这称为链路状态数据库的同步).&nbsp;然后每个路由器就根据这个全网拓扑结构图,&nbsp;使用Dijkstra最短路径算法计算从自己到各目的网络的最优路径,&nbsp;以此构造自己的路由表.&nbsp;在此之后,&nbsp;当链路状态发生变化时,&nbsp;每个路由器重新计算到各目的网络的最优路径,&nbsp;构造新的路由表.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;OSPF的链路状态数据库能较快的进行更新,&nbsp;使各个路由器能及时更新其路由表.&nbsp;OSPF的更新过程收敛得快是其重要的优点.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;{注意:&nbsp;虽然使用Dijkstra算法能够计算出完整的最优路径,&nbsp;但是路由表不会存储完整路径,&nbsp;而只存储”下一跳”(只有到了下一跳路由器,&nbsp;才能知道再下一跳应当怎么走)}</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;"><span style="font-size:18px;"><strong>划分区域</strong></span></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;为了使OSPF能够用于规模很大的网络,&nbsp;OSPF将一个自治系统再划分为若干个更小的范围,&nbsp;叫做<span style="color:rgb(0,0,255);">区域</span>.&nbsp;每一个区域都有一个32位的区域标示符(用点分十进制表示).&nbsp;区域也不能太大,&nbsp;在一个区域内的路由器最好不要超过200个.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;划分区域的好处是:&nbsp;将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统,&nbsp;这就减少了整个网络上的通信量.&nbsp;由于区域内部路由器仅与同区域的路由器交换LSA信息,这样<span style="color:rgb(0,0,255);">LSA报文数量及链路状态信息库表项都会极大减少</span><span style="color:rgb(0,0,255);">,</span><span style="color:rgb(0,0,255);">SPF计算速度因此得到提高</span>。</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;在一个区域内部的路由器只知道本区域的完整网络拓扑,&nbsp;而不知道其他区域的网络拓扑情况.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;这些区域也有层次之分,&nbsp;处在上层的域叫做主干区域,&nbsp;负责连通其他下层的区域,&nbsp;并且还连接其他自治域;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>OSPF分组类型与OSPF工作过程</strong></span></p>
<table><tbody><tr><td valign="top" style="background:rgb(155,187,89);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">类型</span></span><br></td><td valign="top" style="background:rgb(155,187,89);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">用途</span></span><br></td></tr><tr><td valign="top" style="background:rgb(215,227,188);"><br><br><span style="font-family:Courier New;">问候分组</span><br></td><td valign="top" style="background:rgb(215,227,188);"><br><br><span style="font-family:Courier New;">用来发现和维持邻站的可达性</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">数据库描述分组</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">向邻站发送自己的链路状态数据库中的所有链路状态项目的摘要信息</span><br></td></tr><tr><td valign="top" style="background:rgb(215,227,188);"><br><br><span style="font-family:Courier New;">链路状态请求分组</span><br></td><td valign="top" style="background:rgb(215,227,188);"><br><br><span style="font-family:Courier New;">向对方请求发送某些链路状态项目的详细信息</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">链路状态更新分组</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">用洪泛法对全网更新链路状态</span><br></td></tr><tr><td valign="top" style="background:rgb(215,227,188);"><br><br><span style="font-family:Courier New;">链路状态确认分组</span><br></td><td valign="top" style="background:rgb(215,227,188);"><br><br><span style="font-family:Courier New;">对链路更新分组的确认</span><br></td></tr></tbody></table>

<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;通常每隔10秒,&nbsp;每两个相邻路由器就要交换一次<span style="color:rgb(0,0,255);">问候分组</span>,&nbsp;以便知道哪些站可达.&nbsp;    </span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(1)<span style="color:rgb(255,0,0);">在路由器刚开始工作时</span>,&nbsp;OSPF让每一个路由器使用<span style="color:rgb(0,0,255);">数据库描述分组</span>和相邻路由器交换本数据库中已有的链路状态摘要信息.&nbsp;然后,&nbsp;路由器就使用<span style="color:rgb(0,0,255);">链路状态请求分组</span>向对方请求发送<span style="color:rgb(255,0,0);">自己所缺少的某些链路状态项目的详细信息</span>.&nbsp;经过一系列的这种分组交换,&nbsp;全网同步的链路数据库就建立了.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(2)<span style="color:rgb(255,0,0);">在网络运行的过程中</span>,&nbsp;只要一个路由器的链路状态发生变化,&nbsp;该路由器就要使用<span style="color:rgb(0,0,255);">链路状态更新分组</span>,&nbsp;用洪泛法向全网更新链路状态.&nbsp;其他路由器在更新后,&nbsp;发送<span style="color:rgb(0,0,255);">链路状态确认分组</span>对更新进行确认.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;(3)<span style="color:rgb(255,0,0);">为了确保链路状态数据库与全网的状态保持一致</span>,&nbsp;OSPF还规定每隔一段时间(如30分钟),&nbsp;要刷新一次数据库中的链路状态.&nbsp;由于一个路由器的链路状态只涉及与相邻路由器的连通状态,&nbsp;因而与整个互联网的规模并无直接关系.&nbsp;因此,&nbsp;当互联网规模很大时,&nbsp;OSPF协议要比RIP好得多,&nbsp;而且OSPF协议没有”坏消息传的慢”的问题.</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<h2 id="BGP协议"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">BGP协议</span></span></h2><p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;BGP(Border&nbsp;Gateway&nbsp;Protocol)是一种不同自治系统的路由器之间交换路由信息的协议,&nbsp;它的基本功能是在<span style="color:rgb(255,0,0);">自治系统间自动交换无环路的路由信息</span>,&nbsp;他是一种外部网关协议(EGP),&nbsp;边界网关协议常常应用于互联网的网关之间.&nbsp;路由表包含已知路由器的列表,&nbsp;路由器能够到达的地址以及到达每个路由器的跳数.</span></p>
<p><span style="font-family:Courier New;">由于:</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)&nbsp;因特网的规模太大,&nbsp;使得自治系统之间路由选择非常困难;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)&nbsp;对于自治系统之间的路由选择,&nbsp;要寻找最佳路由是很不现实的;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)&nbsp;自治系统之间的路由选择必须考虑有关策略;</span></p>
<p><span style="font-family:Courier New;">因此,&nbsp;边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子),&nbsp;而非要找到一条最佳路由.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;BGP采用的是”路径向量选择协议”,&nbsp;他与距离向量协议和链路状态协议都有很大的区别.&nbsp;BGP是应用层协议,&nbsp;他是基于TCP的;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>BGP协议工作原理</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;每一个自治系统管理员要选择至少一个路由器(可以有多个)作为该自治系统的”BGP发言人”.&nbsp;一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息,&nbsp;就要首先建立TCP连接,&nbsp;然后在此连接上交换BGP报文以建立BGP会话,&nbsp;再利用BGP会话交换路由信息.&nbsp;当所有BGP发言人都互相交换网络可达性信息之后,&nbsp;各BGP发言人就可找出到达各个自治系统的比较好的路由.</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;每个BGP发言人除了必须运行BGP协议外,&nbsp;还必须运行该AS所使用的内部网关协议(如OSPF,RIP等),&nbsp;BGP所交换的网络可达性信息就是要到达某个网络(用网络前缀表示)所要经历的一系列AS;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>BGP协议特点:</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)&nbsp;BGP协议交换路由信息的结点数量级是自治系统的数量级,&nbsp;这要比这些自治系统中的网络数少得多;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)&nbsp;每一个自治系统中BGP发言人(或边界路由器)的数目是很少的.&nbsp;这样就使得自治系统之间的路由选择不致过分复杂;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)&nbsp;BGP支持CIDR,&nbsp;因此BGP的路由表也就应当包括目的网络前缀,&nbsp;下一跳路由器,&nbsp;以及到达该目的网络所要经过的各个自治系统序列;</span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;4)&nbsp;在BGP刚运行时,&nbsp;BGP的邻站是交换整个的BGP路由表,&nbsp;但以后只需要在发生变化时更新有变化的部分.&nbsp;这样做对节省网络带宽和减少路由器的处理开销方面都有好处;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>BGP-4使用的四种报文</strong></span></p>
<table><tbody><tr><td valign="top" style="background:rgb(192,80,77);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">打开(open)报文</span></span><br></td><td valign="top" style="background:rgb(192,80,77);"><br><br><span style="font-family:Courier New;"><span style="color:rgb(255,255,255);">用来与相邻的另一个</span><span style="color:rgb(255,255,255);">BGP发言人建立关系</span></span><br></td></tr><tr><td valign="top" style="background:rgb(229,185,183);"><br><br><span style="font-family:Courier New;">更新(update)报文</span><br></td><td valign="top" style="background:rgb(229,185,183);"><br><br><span style="font-family:Courier New;">用来发送某一路由的信息,&nbsp;以及列出要撤销的多条路由.</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">保活(keep-alive)报文</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">用来确认打开报文和周期性地证实邻站关系</span><br></td></tr><tr><td valign="top" style="background:rgb(229,185,183);"><br><br><span style="font-family:Courier New;">通知(notification)报文</span><br></td><td valign="top" style="background:rgb(229,185,183);"><br><br><span style="font-family:Courier New;">用来发送检测到的差错</span><br></td></tr></tbody></table><span style="font-family:Courier New;"><br></span><br><br>## <span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">IP组播与IGMP协议</span></span><br><br><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407210950958?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp; 使用组播的缘由是:&nbsp;有的应用程序要把一个分组发送给多个目的主机.&nbsp;不是让源主机给每一个目的主机都发送一个单独的分组,&nbsp;而是让源主机把单个分组发送给一个组播地址,&nbsp;该组播地址标识一组地址.&nbsp;<span style="color:rgb(255,0,0);">网络把这个分组给该组中的每一个主机都投递一份拷贝</span>(单播与组播的比较示意图如上图所示).&nbsp;主机可以选择加入/离开一个组,&nbsp;从而一个主机可以同时属于多个组;&nbsp;主机使用一个称作IGMP(因特网组管理协议)的协议加入组播组.</span><br><br><span style="font-family:Courier New;">需要注意:</span><br><br><span style="font-family:Courier New;"><span style="color:rgb(255,0,0);">&nbsp; &nbsp;&nbsp;(1)</span><span style="color:rgb(255,0,0);">主机组播时仅发送一份数据</span>,&nbsp;只有数据在传送路径出现分岔时才将分组复制后继续转发.&nbsp;这样对发送者而言,&nbsp;数据只需发送一次就可以发送到所有接收者,&nbsp;大大减轻了网络的负载和发送者的负担.&nbsp;</span><br><br><span style="font-family:Courier New;"><span style="color:rgb(255,0,0);">&nbsp; &nbsp;&nbsp;(2)</span><span style="color:rgb(255,0,0);">组播需要路由器的支持才能实现</span>,&nbsp;能够运行组播协议的路由器称为组播路由器.</span><br><br><span style="font-family:Courier New;">&nbsp;</span><br><br><span style="font-family:Courier New;font-size:18px;"><strong>IP组播地址</strong></span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;IP组播使用D类地址格式.&nbsp;D类地址的前四位是1110,&nbsp;因此D类地址范围为224.0.0.0~239.255.255.255.&nbsp;每一个D类IP地址标志一个组播组;</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;组播数据报和一般IP数据报的区别在于它使用D类IP地址仅作为目的地址,&nbsp;并且首部中协议字段值为2,&nbsp;表明使用IGMP协议.&nbsp;需要注意的是:</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)组播数据报也是”尽最大努力交付”,&nbsp;不提供可靠交付(组播一定是仅应用于UDP);</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)组播地址只能用于目的地址,&nbsp;而不能用于源地址;</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;3)组播数据报不产生ICMP差错报文.&nbsp;因此,&nbsp;若在ping命令后面键入组播地址,&nbsp;则永远不会收到响应;</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;4)并非所有的D类地址都可以作为组播地址;</span><br><br><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407211044263?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><br><br><span style="font-family:Courier New;">IP组播地址与MAC地址映射</span><br><br><span style="font-family:Courier New;">&nbsp;</span><br><br><span style="font-family:Courier New;font-size:18px;"><strong>IGMP协议</strong></span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;IGMP协议用来在IP主机和与其直接相邻的组播路由器之间建立、维护<span style="color:rgb(255,0,0);">组播组成员关系</span>。&nbsp;组播路由器不需要保存所有主机的成员关系,它只是通过IGMP协议了解每个接口连接的网段上是否存在某个组播组的组成员。而主机只需要保存自己加入了哪些组播组。</span><br><br><span style="font-family:Courier New;">    &nbsp; &nbsp;&nbsp;简而言之,IGMP协议是让连接在本地局域网上的组播路由器知道本局域网上是否有主机上的某个进程参加或退出了某个组播组。</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;IGMP应视作TCP/IP协议的一部分,&nbsp;其工作可以分为两个阶段:</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;1)&nbsp;当某个主机加入新的组播组时,&nbsp;该主机应向组播组的组播地址发送一个IGMP报文,&nbsp;声明自己要成为该组的成员.&nbsp;本地组播路由器收到ICMP报文后,&nbsp;将组成员关系转发给因特网上其他的组播路由器.</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;2)&nbsp;因为组成员的关系是动态的,&nbsp;本地组播路由器要周期性地探询本地局域网上的路由器,&nbsp;以便知道这些主机是否还继续是组的成员.&nbsp;只要对某个组有一个主机响应,&nbsp;那么组播路由器就认为这个组是活跃的.&nbsp;但一个组在经过几次探询之后仍然没有一个主机响应,&nbsp;则不再将该组的成员关系转发给其他的组播路由器.</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;组播路由选择实际上就是要找出以源主机为根节点的组播转发树,&nbsp;其中每一个分组在每条链路上只传送一次(即在组播转发树上的路由器不会收到重复的组播数据报).&nbsp;对不同的多播组对应于不同的多播转发树;&nbsp;同一个多播组,&nbsp;对不同的源点也会有不同的多播转发树.</span><br><br><span style="font-family:Courier New;"><img src="http://img.blog.csdn.net/20150407211144261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><img src="http://img.blog.csdn.net/20150407212554700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span><br><br><span style="font-family:Courier New;"><br></span><br><br><span style="font-family:Courier New;">[附]组播/广播/单播的不同</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp; 广播是指在IP子网内广播数据包,<span style="color:rgb(255,0,0);">所有在子网内部的主机都将收到这些数据包</span>。广播意味着网络向子网每一个主机都投递一份数据包,不论这些主机是否乐于接收该数据包。所以广播的使用范围非常小,只在本地子网内有效,通过路由器和网络设备控制广播传输。</span><br><br><span style="font-family:Courier New;"><span style="color:rgb(255,0,0);">&nbsp; &nbsp;&nbsp;广播地址</span>是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP&nbsp;协议的网络中,主机标识段host&nbsp;ID&nbsp;为全1&nbsp;的IP&nbsp;地址为广播地址,广播的分组传送给host&nbsp;ID段所涉及的所有计算机。如,对于10.1.1.0&nbsp;(255.255.255.0&nbsp;)网段,其广播地址为10.1.1.255,当发出一个目的地址为10.1.1.255&nbsp;的分组时,它将被分发给该网段上的所有计算机。</span><br><br><span style="font-family:Courier New;">&nbsp; &nbsp;&nbsp;组播协议与现在广泛使用的单播协议的不同之处在于,一个主机用<span style="color:rgb(255,0,0);background:rgb(255,255,0);">单播</span>协议向n个主机发送相同的数据时,发送主机需要分别向n个主机发送,共发送n次。一个主机用组播协议向n个主机发送相同的数据时,只要发送1次,其数据由网络中的路由器和交换机逐级进行复制并发送给各个接收方,这样既节省服务器资源也节省网络主干的带宽资源。</span><br><br><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407211151484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><br><br>## <span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">路由表的内容</span></span><br><table cellpadding="0" cellspacing="0"></table>

<p><span style="font-family:Courier New;">&nbsp; &nbsp; 标准的路由表最少应具有四个项目:&nbsp;目的网络IP地址,&nbsp;子网掩码,&nbsp;下一跳IP地址和接口;&nbsp;而Linux系统中的路由表包含有如图所示内容:</span></p>
<p><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407211329830?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<table><tbody><tr><td valign="top" style="background:rgb(128,100,162);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">Destination</span></span><br></td><td valign="top" style="background:rgb(128,100,162);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">目标网络或主机</span></span><br></td></tr><tr><td valign="top" style="background:rgb(204,193,217);"><br><br><span style="font-family:Courier New;">Gateway</span><br></td><td valign="top" style="background:rgb(204,193,217);"><br><br><span style="font-family:Courier New;">网关地址,&nbsp;*代表是目标和本机在同一个网络,&nbsp;不需要路由</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">Genmask</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">网络掩码</span><br></td></tr><tr><td valign="top" style="background:rgb(204,193,217);"><br><br><span style="font-family:Courier New;">Flags</span><br></td><td valign="top" style="background:rgb(204,193,217);"><br><br><span style="font-family:Courier New;">路由项标志,&nbsp;常见的标志有如下5种:</span><br><br><span style="font-family:Courier New;">&nbsp;&nbsp;U:&nbsp;该路由项是活动的</span><br><br><span style="font-family:Courier New;">&nbsp;&nbsp;H:&nbsp;该路由项的目标是一台主机</span><br><br><span style="font-family:Courier New;">&nbsp;&nbsp;G:&nbsp;该路由项的目标是网关</span><br><br><span style="font-family:Courier New;">&nbsp;&nbsp;D:&nbsp;该路由项是由重定向生成的</span><br><br><span style="font-family:Courier New;">&nbsp;&nbsp;M:&nbsp;该路由项被重定向修改过</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">Metric</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">路由距离,&nbsp;即到达指定网络所需的中转数</span><br></td></tr><tr><td valign="top" style="background:rgb(204,193,217);"><br><br><span style="font-family:Courier New;">Ref</span><br></td><td valign="top" style="background:rgb(204,193,217);"><br><br><span style="font-family:Courier New;">该路由项被引用的次数(Linux未使用)</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">Use</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">该路由项被使用的次数</span><br></td></tr><tr><td valign="top" style="background:rgb(204,193,217);"><br><br><span style="font-family:Courier New;">Iface</span><br></td><td valign="top" style="background:rgb(204,193,217);"><br><br><span style="font-family:Courier New;">该路由项对应的输出网卡接口</span><br></td></tr></tbody></table>

<p><span style="font-family:Courier New;">&nbsp;</span></p>
<h2 id="IPv6简介"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">IPv6简介</span></span></h2><p><span style="font-family:Courier New;font-size:18px;"><strong>IPv6数据报格式</strong></span></p>
<p><span style="font-family:Courier New;">&nbsp; &nbsp; IPv6数据报的基本首部长度变为固定的40字节,首部只有8个字段,&nbsp;称为基本首部,&nbsp;用扩展首部取代了IPv4首部中的可选项,&nbsp;将不必要的功能取消了,&nbsp;便于中间节点高效率对其进行处理。</span></p>
<table cellpadding="0" cellspacing="0"></table>

<p><span style="font-family:Courier New;">&nbsp;<img src="http://img.blog.csdn.net/20150407211450011?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>IPv6基本首部</strong></span></p>
<p><span style="font-family:Courier New;"><img src="http://img.blog.csdn.net/20150407211420561?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></p>
<p><span style="font-family:Courier New;">    <span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>IPv6数据报的基本首部是40字节的固定首部,其携带的信息为数据报传输途中经过的节点都必须处理的信息。</span></p>
<table cellpadding="0" cellspacing="0"></table><table><tbody><tr><td width="568" valign="top" colspan="2" style="background:rgb(247,150,70);"><br><br><span style="color:rgb(255,255,255);"><span style="font-family:Courier New;">IPv6首部字段含义</span></span><br></td></tr><tr><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">版本(version)</span><br></td><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">4位</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">通信类型(traffic&nbsp;class)</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">8位,&nbsp;用来区分不同的IPv6数据报的类别或优先级</span><br></td></tr><tr><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">流标签(flow&nbsp;label)</span><br></td><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">20位,&nbsp;所谓流就是因特网上从特定源到特定目的的一系列数据报。而在这个“流”所经过的路径上的路由器都保证指定的服务质量(QoS)。所有属于同一个流的数据报都有相同的流标识</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">有效载荷长度(payload&nbsp;length)</span><br><br><span style="font-family:Courier New;">&nbsp;</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">16&nbsp;位,&nbsp;基本首部以外的字节数,包括扩展首部和数据部分</span><br></td></tr><tr><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">下一首部(头)(next&nbsp;header)</span><br></td><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">8位,&nbsp;定义了紧跟在基本首部后面的扩展首部的数字标识号或数据部分的协议类型。</span><br><br><span style="font-family:Courier New;">若没有扩展首部,相当于IPv4中的协议字段。</span><br><br><span style="font-family:Courier New;">若有扩展首部,用来说明紧跟在基本首部后的第一个扩展首部的数字标识号,即是扩展首部的类型。</span><br><br><span style="font-family:Courier New;">每个扩展首部也包含下一首部字段,下一首部的数字标识号在RFC&nbsp;1700中定义。</span><br></td></tr><tr><td valign="top"><br><br><span style="font-family:Courier New;">跳数极限/跃点限制(hop&nbsp;limit)</span><br></td><td valign="top"><br><br><span style="font-family:Courier New;">8位。其作用类似于IPv4的TTL字段</span><br></td></tr><tr><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">源/目的地址(source/destination&nbsp;&nbsp;address)</span><br></td><td valign="top" style="background:rgb(251,213,181);"><br><br><span style="font-family:Courier New;">各128位,&nbsp;标识发送/接收数据报节点的IPv6地址</span><br></td></tr></tbody></table>

<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>IPv6数据报格式的主要变化</strong></span></p>
<p><span style="font-family:Courier New;">    <span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(1)取消<span style="color:rgb(255,0,0);">首部的校验和字段</span>。提高数据报的传输效率。</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(2)基本首部增加了<span style="color:rgb(255,0,0);">流标识和传输类别字段</span>,以加强对多媒体实时数据传送的支持。</span></p>
<p><span style="font-family:Courier New;">    <span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(3)增加了<span style="color:rgb(255,0,0);">鉴别扩展首部(Authentication&nbsp;Header</span><span style="color:rgb(255,0,0);">,</span><span style="color:rgb(255,0,0);">AH)和加密安全载荷扩展首部(Encapsulating&nbsp;Security&nbsp;Payload&nbsp;header</span><span style="color:rgb(255,0,0);">,</span><span style="color:rgb(255,0,0);">ESP)</span>,以增强安全性。</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(4)所有的扩展首部和数据合起来叫数据报的有效载荷/净载荷;</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>IPv6地址表示方法</strong></span></p>
<p><span style="font-family:Courier New;">    <span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>1、用十六进制表示,4位一组,中间用“:”隔开,如:FE08:….</span></p>
<p><span style="font-family:Courier New;">    <span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>2、零压缩,&nbsp;若以零开头可以省略,全零的组可用“::”表示,如:&nbsp;1:2::ACDR:….</span></p>
<p><span style="font-family:Courier New;">    <span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>3、地址前缀长度用“/xx”来表示,如：　1::1/64</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<p><span style="font-family:Courier New;font-size:18px;"><strong>IPv6主要特点</strong></span></p>
<p><span style="font-family:Courier New;">    <span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>简化的报头和灵活的扩展</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>层次化的地址结构</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>即插即用的连网方式</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>网络层的认证与加密</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>服务质量的满足</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>对移动通讯更好的支持</span></p>
<p><span style="font-family:Courier New;">&nbsp;</span></p>
<h2 id="移动IP的基本通信流程"><span style="color:rgb(255, 0, 0);"><span style="font-family:Courier New;">移动IP的基本通信流程</span></span></h2><p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(1)<span style="color:rgb(0,0,255);">本地代理</span>和<span style="color:rgb(0,0,255);">外地代理</span>不停地向网上发送代理广告消息,以声明自己的存在。</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(2)移动主机收到这些消息,确定自己是在本地网还是在外地网。</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(3)如果移动主机发现自己仍在<span style="color:rgb(0,0,255);">本地网</span>,即收到的是本地代理发来的消息,则不启动移动功能。如果是从<span style="color:rgb(0,0,255);">外地网络重新返回的</span>,则向本地代理发出<span style="color:rgb(0,0,255);">取消注册</span>的消息,声明自己回到了本地网。</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(4)当移动主机检测到它移动到<span style="color:rgb(0,0,255);">外地网</span>时,则获得接管地址。</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(5)然后移动主机向本地代理登记,<span style="color:rgb(0,0,255);">表明自己已离开本地网</span>,把所获得的接管地址通知本地代理。</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(6)登记完毕后,所有发给移动主机的数据包被本地代理截获,经本地代理封装后,通过<span style="color:rgb(0,0,255);">隧道</span>发到外地网络的外地代理或移动主机自身。第一种情况下,外地代理再把数据包转发给移动主机。此时,数据包在不同子网间传送成功。</span></p>
<p><span style="font-family:Courier New;"><span style="font-family: 'Courier New';">&nbsp; &nbsp;&nbsp;</span>(7)移动主机发送数据到一般的IP主机时,按正常的IP寻址方法发送,不必通过本地代理。</span></p>
<p>原文转载自汗青ZJF <a href="http://blog.csdn.net/zjf280441589/article/category/1854365" target="_blank" rel="external">http://blog.csdn.net/zjf280441589/article/category/1854365</a></p>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/source/tags/TCP-IP/" rel="tag">#TCP/IP</a>
          
            <a href="/source/tags/网络层/" rel="tag">#网络层</a>
          
            <a href="/source/tags/计算机网络/" rel="tag">#计算机网络</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/TCPIP入门(1)--链路层/" rel="next" title="TCP/IP入门(1) --链路层">
                <i class="fa fa-chevron-left"></i> TCP/IP入门(1) --链路层
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/TCPIP入门(3)--传输层/" rel="prev" title="TCP/IP入门(3) --传输层">
                TCP/IP入门(3) --传输层 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2017/TCPIP入门(2)--网络层/"
     data-title="TCP/IP入门(2) --网络层"
     data-content=""
     data-url="http://yoursite.com/2017/TCPIP入门(2)--网络层/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/TCPIP入门(2)--网络层/"
           data-title="TCP/IP入门(2) --网络层" data-url="http://yoursite.com/2017/TCPIP入门(2)--网络层/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Mr.Zhang" />
          <p class="site-author-name" itemprop="name">Mr.Zhang</p>
          <p class="site-description motion-element" itemprop="description">伟大的工作，并不是用力量而是用耐心去完成的。 —— 约翰逊</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhangxiaochen" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是虚拟网络互连? "><span class="nav-number">1.</span> <span class="nav-text">什么是虚拟网络互连? </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP报文"><span class="nav-number">2.</span> <span class="nav-text">IP报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP地址分类"><span class="nav-number">3.</span> <span class="nav-text">IP地址分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分组转发算法"><span class="nav-number">4.</span> <span class="nav-text">分组转发算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子网划分"><span class="nav-number">5.</span> <span class="nav-text">子网划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无分类编址(CIDR) "><span class="nav-number">6.</span> <span class="nav-text">无分类编址(CIDR) </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络地址转换NAT"><span class="nav-number">7.</span> <span class="nav-text">网络地址转换NAT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP协议"><span class="nav-number">8.</span> <span class="nav-text">ARP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DHCP协议"><span class="nav-number">9.</span> <span class="nav-text">DHCP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP协议"><span class="nav-number">10.</span> <span class="nav-text">ICMP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RIP协议"><span class="nav-number">11.</span> <span class="nav-text">RIP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OSPF协议"><span class="nav-number">12.</span> <span class="nav-text">OSPF协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BGP协议"><span class="nav-number">13.</span> <span class="nav-text">BGP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPv6简介"><span class="nav-number">14.</span> <span class="nav-text">IPv6简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移动IP的基本通信流程"><span class="nav-number">15.</span> <span class="nav-text">移动IP的基本通信流程</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhangxiaochen"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
